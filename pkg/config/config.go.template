package config

import (
	"fmt"
	"math/big"

	"github.com/threefoldtech/rivine/build"
	"github.com/threefoldtech/rivine/modules"
	"github.com/threefoldtech/rivine/types"
)

var (
	rawVersion = "v0.1"
	// Version of the chain binaries.
	//
	// Value is defined by a private build flag,
	// or hardcoded to the latest released tag as fallback.
	Version build.ProtocolVersion
)

const (
	// TokenUnit defines the unit of one Token.
	TokenUnit = "{{.Blockchain.Currency.Unit}}"
	// TokenChainName defines the name of the chain.
	TokenChainName = "{{.Blockchain.Name}}"
)

// chain names
const (
	NetworkNameStandard = "standard"
	NetworkNameTest     = "testnet"
	NetworkNameDev      = "devnet"
)

// global network config constants
const (
	BlockFrequency types.BlockHeight = 120 // 1 block per 2 minutes on average
)

// GetBlockchainInfo returns the naming and versioning of tfchain.
func GetBlockchainInfo() types.BlockchainInfo {
	return types.BlockchainInfo{
		Name:            TokenChainName,
		NetworkName:     NetworkNameTest,
		CoinUnit:        TokenUnit,
		ChainVersion:    Version,       // use our own blockChain/build version
		ProtocolVersion: build.Version, // use latest available rivine protocol version
	}
}

// GetStandardnetGenesis explicitly sets all the required constants for the genesis block of the standard (prod) net
func GetStandardnetGenesis() types.ChainConstants {
	cfg := types.StandardnetChainConstants()
  {{range .Blockchain.Network}}{{if eq .NetworkType 1}}
	// set transaction versions
	cfg.DefaultTransactionVersion = types.TransactionVersionOne
	cfg.GenesisTransactionVersion = types.TransactionVersionOne

	// 2 minute block time
	cfg.BlockFrequency = {{.BlockFrequency}}

	// Payouts take roughly 1 day to mature.
	cfg.MaturityDelay = {{.MaturityDelay}}

  // The genesis timestamp
  cfg.GenesisTimestamp = types.Timestamp({{.Genesis.GenesisBlockTimestamp}})

	// 1000 block window for difficulty
	cfg.TargetWindow = {{.TargetWindow}}

	cfg.MaxAdjustmentUp = big.NewRat({{.MaxAdjustmentUp.Denominator}}, {{.MaxAdjustmentUp.Numerator}})
	cfg.MaxAdjustmentDown = big.NewRat({{.MaxAdjustmentDown.Denominator}}, {{.MaxAdjustmentDown.Numerator}})

	cfg.FutureThreshold = {{.FutureThreshold}}        // 1 hour.
	cfg.ExtremeFutureThreshold = {{.ExtremeFutureThreshold}} // 2 hours.

	cfg.StakeModifierDelay = {{.StakeModifierDelay}}

	// Blockstakes can be used roughly 1 day after receiving
	cfg.BlockStakeAging = {{.BlockStakeAging}}

	// Receive 0 coins when you create a block
	cfg.BlockCreatorFee = cfg.CurrencyUnits.OneCoin.Mul64({{.BlockCreatorFee}})

	// Use 0.001 coins as minimum transaction fee
	cfg.MinimumTransactionFee = cfg.CurrencyUnits.OneCoin.Div64({{.MinimumTransactionFee}} * 100)

  // Foundation receives all transactions fees in a single pool address,
  cfg.TransactionFeeCondition = types.NewCondition(types.NewUnlockHashCondition(unlockHashFromHex("{{ .TransactionFeePool }}")))

	// no  initial coins, except  1 for initial transaction fee payments
	cfg.GenesisCoinDistribution = []types.CoinOutput{}

  // allocate block stakes
  cfg.GenesisBlockStakeAllocation = []types.BlockStakeOutput{
    {{ range .Genesis.BlockStakeOutputs }}{
      Value:     types.NewCurrency64({{.Value}}),
      Condition: types.NewCondition(types.NewUnlockHashCondition(unlockHashFromHex("{{.Condition | formatConditionAsString -}}"))),
    },
    {{ end }}
  }

  {{end}}{{end}}return cfg
}

// GetTestnetGenesis explicitly sets all the required constants for the genesis block of the testnet
func GetTestnetGenesis() types.ChainConstants {
	cfg := types.TestnetChainConstants()
  {{range .Blockchain.Network}}{{if eq .NetworkType 2}}
	// set transaction versions
	cfg.DefaultTransactionVersion = types.TransactionVersionOne
	cfg.GenesisTransactionVersion = types.TransactionVersionOne

	cfg.BlockFrequency = {{.BlockFrequency}}

	cfg.MaturityDelay = {{.MaturityDelay}}

  // The genesis timestamp
  cfg.GenesisTimestamp = types.Timestamp({{.Genesis.GenesisBlockTimestamp}})

	cfg.TargetWindow = {{.TargetWindow}}

	cfg.MaxAdjustmentUp = big.NewRat({{.MaxAdjustmentUp.Denominator}}, {{.MaxAdjustmentUp.Numerator}})
	cfg.MaxAdjustmentDown = big.NewRat({{.MaxAdjustmentDown.Denominator}}, {{.MaxAdjustmentDown.Numerator}})

	cfg.FutureThreshold = {{.FutureThreshold}}
	cfg.ExtremeFutureThreshold = {{.ExtremeFutureThreshold}}

	cfg.StakeModifierDelay = {{.StakeModifierDelay}}

	cfg.BlockStakeAging = {{.BlockStakeAging}}

	cfg.BlockCreatorFee = cfg.CurrencyUnits.OneCoin.Mul64({{.BlockCreatorFee}})

	cfg.MinimumTransactionFee = cfg.CurrencyUnits.OneCoin.Div64({{.MinimumTransactionFee}} * 100)


	// allocate block stakes
  cfg.GenesisCoinDistribution = []types.CoinOutput{
    {{ range .Genesis.CoinOutputs }}{
        Value: cfg.CurrencyUnits.OneCoin.Mul64({{ .Value }}),
        Condition: types.NewCondition(types.NewUnlockHashCondition(unlockHashFromHex("{{.Condition | formatConditionAsString -}}"))),
      },
    {{ end }}
  }

  // allocate block stakes
  cfg.GenesisBlockStakeAllocation = []types.BlockStakeOutput{
    {{ range .Genesis.BlockStakeOutputs }}{
      Value:     types.NewCurrency64({{.Value}}),
      Condition: types.NewCondition(types.NewUnlockHashCondition(unlockHashFromHex("{{.Condition | formatConditionAsString -}}"))),
    },
    {{ end }}
  }

  {{end}}{{end}}return cfg
}

// GetDevnetGenesis explicitly sets all the required constants for the genesis block of the devnet
func GetDevnetGenesis() types.ChainConstants {
	cfg := types.DevnetChainConstants()
  {{range .Blockchain.Network}}{{if eq .NetworkType 3}}
	// set transaction versions
	cfg.DefaultTransactionVersion = types.TransactionVersionOne
	cfg.GenesisTransactionVersion = types.TransactionVersionOne

	cfg.BlockFrequency = {{.BlockFrequency}}

	cfg.MaturityDelay = {{.MaturityDelay}}

  // The genesis timestamp
  cfg.GenesisTimestamp = types.Timestamp({{.Genesis.GenesisBlockTimestamp}})

	cfg.TargetWindow = {{.TargetWindow}}

	cfg.MaxAdjustmentUp = big.NewRat({{.MaxAdjustmentUp.Denominator}}, {{.MaxAdjustmentUp.Numerator}})
	cfg.MaxAdjustmentDown = big.NewRat({{.MaxAdjustmentDown.Denominator}}, {{.MaxAdjustmentDown.Numerator}})

	cfg.FutureThreshold = {{.FutureThreshold}}
	cfg.ExtremeFutureThreshold = {{.ExtremeFutureThreshold}}

	cfg.StakeModifierDelay = {{.StakeModifierDelay}}

	cfg.BlockStakeAging = {{.BlockStakeAging}}

	cfg.BlockCreatorFee = cfg.CurrencyUnits.OneCoin.Mul64({{.BlockCreatorFee}})

	cfg.MinimumTransactionFee = cfg.CurrencyUnits.OneCoin.Div64({{.MinimumTransactionFee}} * 100)


	// allocate block stakes
  cfg.GenesisCoinDistribution = []types.CoinOutput{
    {{ range .Genesis.CoinOutputs }}{
        Value: cfg.CurrencyUnits.OneCoin.Mul64({{ .Value }}),
        Condition: types.NewCondition(types.NewUnlockHashCondition(unlockHashFromHex("{{.Condition | formatConditionAsString -}}"))),
      },
    {{ end }}
  }

  // allocate block stakes
  cfg.GenesisBlockStakeAllocation = []types.BlockStakeOutput{
    {{ range .Genesis.BlockStakeOutputs }}{
      Value:     types.NewCurrency64({{.Value}}),
      Condition: types.NewCondition(types.NewUnlockHashCondition(unlockHashFromHex("{{.Condition | formatConditionAsString -}}"))),
    },
    {{ end }}
  }

  {{end}}{{end}}return cfg
}

{{range .Blockchain.Network}}{{if eq .NetworkType 1}}// GetStandardnetGenesisAuthCoinCondition returns the genesis auth condition used for the standard (prod) net
{{if .Genesis.Authcoin}}func GetStandardnetGenesisAuthCoinCondition() types.UnlockConditionProxy {
	// TODO: adapt to real condition, also being multi-sig
	return types.NewCondition(types.NewUnlockHashCondition(unlockHashFromHex("{{.Genesis.Authcoin | formatConditionAsString -}}")))
}{{end}}{{end}}{{end}}

// GetStandardnetBootstrapPeers sets the standard bootstrap node addresses
func GetStandardnetBootstrapPeers() []modules.NetAddress {
	return []modules.NetAddress{
    {{range .Blockchain.Network}}{{if eq .NetworkType 1}}{{range .BootstrapPeers}}"{{.Address}}",
    {{end}}{{end}}{{end}}
	}
}

{{range .Blockchain.Network}}{{if eq .NetworkType 2}}// GetTestnetGenesisAuthCoinCondition returns the genesis auth condition used for the testnet
{{if .Genesis.Authcoin}}func GetTestnetGenesisAuthCoinCondition() types.UnlockConditionProxy {
	// @leesmet, to be changed to 1 out of 2 multisig once we have an automated
	// faucet for this
	return types.NewCondition(types.NewUnlockHashCondition(unlockHashFromHex("{{.Genesis.Authcoin | formatConditionAsString -}}")))
}{{end}}{{end}}{{end}}

// GetTestnetBootstrapPeers sets the testnet bootstrap node addresses
func GetTestnetBootstrapPeers() []modules.NetAddress {
	return []modules.NetAddress{
    {{range .Blockchain.Network}}{{if eq .NetworkType 2}}{{range .BootstrapPeers}}"{{.Address}}",
    {{end}}{{end}}{{end}}
	}
}

{{range .Blockchain.Network}}{{if eq .NetworkType 3}}// GetDevnetGenesisAuthCoinCondition returns the genesis auth condition used for the devnet
{{if .Genesis.Authcoin}}func GetDevnetGenesisAuthCoinCondition() types.UnlockConditionProxy {
	return types.NewCondition(types.NewUnlockHashCondition(unlockHashFromHex("{{.Genesis.Authcoin | formatConditionAsString -}}")))
}{{end}}{{end}}{{end}}

// GetDevnetBootstrapPeers sets the default devnet bootstrap node addresses
func GetDevnetBootstrapPeers() []modules.NetAddress {
	return []modules.NetAddress{
		"localhost:{{ .Blockchain.Ports.RPC }}", // TODO: add port
	}
}

func unlockHashFromHex(hstr string) (uh types.UnlockHash) {
	err := uh.LoadString(hstr)
	if err != nil {
		panic(fmt.Sprintf("func unlockHashFromHex(%s) failed: %v", hstr, err))
	}
	return
}

func init() {
	Version = build.MustParse(rawVersion)
}
